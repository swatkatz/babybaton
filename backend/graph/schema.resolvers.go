package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/swatkatz/babybaton/backend/graph/model"
	"github.com/swatkatz/babybaton/backend/internal/ai"
	"github.com/swatkatz/babybaton/backend/internal/domain"
	"github.com/swatkatz/babybaton/backend/internal/mapper"
	"github.com/swatkatz/babybaton/backend/internal/middleware"
	"golang.org/x/crypto/bcrypt"
)

// CreateFamily is the resolver for the createFamily field.
func (r *mutationResolver) CreateFamily(ctx context.Context, familyName string, password string, babyName string, caregiverName string, deviceID string, deviceName *string) (*model.AuthResult, error) {
	// Validate password length
	if len(password) < 6 {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Password must be at least 6 characters"),
		}, nil
	}

	// Check if family name already exists
	exists, err := r.store.FamilyNameExists(ctx, familyName)
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Failed to check family name availability"),
		}, nil
	}
	if exists {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Family name already taken"),
		}, nil
	}

	// Hash password
	passwordHash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Failed to hash password"),
		}, nil
	}

	// Generate IDs
	familyID := uuid.New()
	caregiverID := uuid.New()
	now := time.Now()

	// Create domain objects
	family := &domain.Family{
		ID:           familyID,
		Name:         familyName,
		PasswordHash: string(passwordHash),
		Password:     password,
		BabyName:     babyName,
		CreatedAt:    now,
		UpdatedAt:    now,
	}

	caregiver := &domain.Caregiver{
		ID:         caregiverID,
		FamilyID:   familyID,
		Name:       caregiverName,
		DeviceID:   deviceID,
		DeviceName: deviceName,
		CreatedAt:  now,
		UpdatedAt:  now,
	}

	// Create family and caregiver atomically
	err = r.store.CreateFamilyWithCaregiver(ctx, family, caregiver)
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr(fmt.Sprintf("Failed to create family: %v", err)),
		}, nil
	}

	// Convert to GraphQL types
	return &model.AuthResult{
		Success:   true,
		Family:    mapper.FamilyToGraphQL(family),       // ‚Üê Use mapper
		Caregiver: mapper.CaregiverToGraphQL(caregiver), // ‚Üê Use mapper
		Error:     nil,
	}, nil
}

// JoinFamily is the resolver for the joinFamily field.
func (r *mutationResolver) JoinFamily(ctx context.Context, familyName string, password string, caregiverName string, deviceID string, deviceName *string) (*model.AuthResult, error) {
	family, err := r.store.GetFamilyByName(ctx, familyName)
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Family not found"),
		}, nil
	}

	// Verify password
	err = bcrypt.CompareHashAndPassword([]byte(family.PasswordHash), []byte(password))
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Incorrect password"),
		}, nil
	}

	// Check if device already exists
	existingCaregiver, err := r.store.GetCaregiverByDeviceID(ctx, deviceID)

	// Case 1: Device exists in THIS family ‚Üí Re-authentication (allow it!)
	if err == nil && existingCaregiver != nil && existingCaregiver.FamilyID == family.ID {
		return &model.AuthResult{
			Success:   true,
			Family:    mapper.FamilyToGraphQL(family),
			Caregiver: mapper.CaregiverToGraphQL(existingCaregiver),
			Error:     nil,
		}, nil
	}

	// Case 2: Device exists in DIFFERENT family ‚Üí Block it
	if err == nil && existingCaregiver != nil && existingCaregiver.FamilyID != family.ID {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr("Device already belongs to a different family. Leave that family first."),
		}, nil
	}

	// Case 3: Device doesn't exist ‚Üí Create new caregiver
	caregiverID := uuid.New()
	now := time.Now()

	caregiver := &domain.Caregiver{
		ID:         caregiverID,
		FamilyID:   family.ID,
		Name:       caregiverName,
		DeviceID:   deviceID,
		DeviceName: deviceName,
		CreatedAt:  now,
		UpdatedAt:  now,
	}

	err = r.store.CreateCaregiver(ctx, caregiver)
	if err != nil {
		return &model.AuthResult{
			Success: false,
			Error:   stringPtr(fmt.Sprintf("Failed to join family: %v", err)),
		}, nil
	}

	return &model.AuthResult{
		Success:   true,
		Family:    mapper.FamilyToGraphQL(family),
		Caregiver: mapper.CaregiverToGraphQL(caregiver),
		Error:     nil,
	}, nil
}

// UpdateBabyName is the resolver for the updateBabyName field.
func (r *mutationResolver) UpdateBabyName(ctx context.Context, babyName string) (*model.Family, error) {
	panic(fmt.Errorf("not implemented: UpdateBabyName - updateBabyName"))
}

// LeaveFamily is the resolver for the leaveFamily field.
func (r *mutationResolver) LeaveFamily(ctx context.Context) (bool, error) {
	panic(fmt.Errorf("not implemented: LeaveFamily - leaveFamily"))
}

// StartCareSession is the resolver for the startCareSession field.
func (r *mutationResolver) StartCareSession(ctx context.Context) (*model.CareSession, error) {
	panic(fmt.Errorf("not implemented: StartCareSession - startCareSession"))
}

// ParseVoiceInput is the resolver for the parseVoiceInput field.
func (r *mutationResolver) ParseVoiceInput(ctx context.Context, audioFile graphql.Upload) (*model.ParsedVoiceResult, error) {
	// Step 1: Initialize clients
	whisperClient := ai.NewWhisperClient()
	claudeClient := ai.NewClaudeClient(os.Getenv("CLAUDE_API_KEY"))

	// Step 2: Transcribe audio using Whisper
	fmt.Printf("üì§ Uploading audio: %s (%d bytes, %s)\n", audioFile.Filename, audioFile.Size, audioFile.ContentType)
	transcribedText, err := whisperClient.TranscribeAudio(ctx, audioFile.File, audioFile.Filename)
	if err != nil {
		fmt.Printf("‚ùå Whisper transcription failed: %v\n", err)
		return &model.ParsedVoiceResult{
			Success: false,
			RawText: "",
			Errors:  []string{fmt.Sprintf("Failed to transcribe audio: %v", err)},
		}, nil
	}
	fmt.Printf("‚úÖ Whisper transcription: %q\n", transcribedText)

	// Step 3: Parse transcribed text with Claude
	timezone := middleware.GetTimezone(ctx)
	claudeResponse, err := claudeClient.ParseVoiceInput(transcribedText, time.Now(), timezone)
	if err != nil {
		fmt.Printf("‚ùå Claude parsing failed: %v\n", err)
		return &model.ParsedVoiceResult{
			Success: false,
			RawText: transcribedText,
			Errors:  []string{fmt.Sprintf("Failed to parse voice input: %v", err)},
		}, nil
	}
	fmt.Printf("‚úÖ Claude response: %s\n", claudeResponse)

	// Step 4: Parse Claude's JSON response
	var activities []map[string]interface{}
	if err := json.Unmarshal([]byte(claudeResponse), &activities); err != nil {
		return &model.ParsedVoiceResult{
			Success: false,
			RawText: transcribedText,
			Errors:  []string{fmt.Sprintf("Failed to parse Claude response: %v", err)},
		}, nil
	}

	// Step 5: Convert to GraphQL types
	parsedActivities, conversionErrors := ai.ConvertToParsedActivities(activities)

	// Step 6: Return result
	fmt.Printf("‚úÖ Successfully parsed %d activities\n", len(parsedActivities))
	for i, activity := range parsedActivities {
		fmt.Printf("   Activity %d: Type=%s\n", i+1, activity.ActivityType)
	}
	if len(conversionErrors) > 0 {
		fmt.Printf("‚ö†Ô∏è  Conversion errors: %v\n", conversionErrors)
	}

	return &model.ParsedVoiceResult{
		Success:          true,
		RawText:          transcribedText,
		ParsedActivities: parsedActivities,
		Errors:           conversionErrors,
	}, nil
}

// AddActivities is the resolver for the addActivities field.
func (r *mutationResolver) AddActivities(ctx context.Context, activities []*model.ActivityInput) (*model.CareSession, error) {
	// Step 1: Get authenticated user
	caregiverID, familyID, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Step 2: Get or create in_progress session
	session, err := r.store.GetInProgressSessionForFamily(ctx, familyID)
	if err != nil {
		return nil, fmt.Errorf("failed to get in-progress session: %w", err)
	}

	if session == nil {
		// No active session, create one
		now := time.Now()
		session = &domain.CareSession{
			ID:          uuid.New(),
			CaregiverID: caregiverID,
			FamilyID:    familyID,
			Status:      domain.StatusInProgress,
			StartedAt:   now,
			CreatedAt:   now,
			UpdatedAt:   now,
		}
		if err := r.store.CreateCareSession(ctx, session); err != nil {
			return nil, fmt.Errorf("failed to create care session: %w", err)
		}
		fmt.Printf("‚ú® Created new care session: %s\n", session.ID)
	}

	// Step 3: Add each activity
	fmt.Printf("üìù Adding %d activities to session %s\n", len(activities), session.ID)
	for i, activityInput := range activities {
		now := time.Now()

		// Convert GraphQL ActivityType (FEED, DIAPER, SLEEP) to domain ActivityType (feed, diaper, sleep)
		activityType := strings.ToLower(string(activityInput.ActivityType))

		activity := &domain.Activity{
			ID:            uuid.New(),
			CareSessionID: session.ID,
			ActivityType:  domain.ActivityType(activityType),
			CreatedAt:     now,
			UpdatedAt:     now,
		}

		if err := r.store.CreateActivity(ctx, activity); err != nil {
			return nil, fmt.Errorf("failed to create activity: %w", err)
		}

		// Create activity details based on type
		switch activityInput.ActivityType {
		case model.ActivityTypeFeed:
			if activityInput.FeedDetails == nil {
				return nil, fmt.Errorf("feed activity requires feedDetails")
			}

			// Convert GraphQL FeedType (BREAST_MILK, FORMULA) to domain FeedType (breast_milk, formula)
			var feedType *domain.FeedType
			if activityInput.FeedDetails.FeedType != nil {
				ft := domain.FeedType(strings.ToLower(string(*activityInput.FeedDetails.FeedType)))
				feedType = &ft
			}

			// Convert *int32 to *int for AmountMl
			var amountMl *int
			if activityInput.FeedDetails.AmountMl != nil {
				val := int(*activityInput.FeedDetails.AmountMl)
				amountMl = &val
			}

			details := &domain.FeedDetails{
				ID:         uuid.New(),
				ActivityID: activity.ID,
				StartTime:  activityInput.FeedDetails.StartTime,
				EndTime:    activityInput.FeedDetails.EndTime,
				AmountMl:   amountMl,
				FeedType:   feedType,
				CreatedAt:  now,
				UpdatedAt:  now,
			}
			fmt.Printf("üìù Creating feed details for activity %s (feed_type: %v)\n", activity.ID, feedType)
			if err := r.store.CreateFeedDetails(ctx, details); err != nil {
				return nil, fmt.Errorf("failed to create feed details: %w", err)
			}
			fmt.Printf("‚úÖ Feed details created successfully\n")

		case model.ActivityTypeDiaper:
			if activityInput.DiaperDetails == nil {
				return nil, fmt.Errorf("diaper activity requires diaperDetails")
			}
			hadPee := false
			if activityInput.DiaperDetails.HadPee != nil {
				hadPee = *activityInput.DiaperDetails.HadPee
			}
			details := &domain.DiaperDetails{
				ID:         uuid.New(),
				ActivityID: activity.ID,
				ChangedAt:  activityInput.DiaperDetails.ChangedAt,
				HadPoop:    activityInput.DiaperDetails.HadPoop,
				HadPee:     hadPee,
				CreatedAt:  now,
				UpdatedAt:  now,
			}
			if err := r.store.CreateDiaperDetails(ctx, details); err != nil {
				return nil, fmt.Errorf("failed to create diaper details: %w", err)
			}

		case model.ActivityTypeSleep:
			if activityInput.SleepDetails == nil {
				return nil, fmt.Errorf("sleep activity requires sleepDetails")
			}
			var durationMinutes *int
			if activityInput.SleepDetails.EndTime != nil {
				duration := int(activityInput.SleepDetails.EndTime.Sub(activityInput.SleepDetails.StartTime).Minutes())
				durationMinutes = &duration
			}
			details := &domain.SleepDetails{
				ID:              uuid.New(),
				ActivityID:      activity.ID,
				StartTime:       activityInput.SleepDetails.StartTime,
				EndTime:         activityInput.SleepDetails.EndTime,
				DurationMinutes: durationMinutes,
				CreatedAt:       now,
				UpdatedAt:       now,
			}
			if err := r.store.CreateSleepDetails(ctx, details); err != nil {
				return nil, fmt.Errorf("failed to create sleep details: %w", err)
			}
		}

		fmt.Printf("   ‚úÖ Activity %d: %s\n", i+1, activity.ActivityType)
	}

	// Step 4: Return the updated session
	return mapper.CareSessionToGraphQL(session), nil
}

// EndActivity is the resolver for the endActivity field.
func (r *mutationResolver) EndActivity(ctx context.Context, activityID string, endTime *time.Time) (model.Activity, error) {
	// Require authentication
	_, _, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	activityUUID, err := uuid.Parse(activityID)
	if err != nil {
		return nil, fmt.Errorf("invalid activity ID: %w", err)
	}

	// Get the activity
	activity, err := r.store.GetActivityByID(ctx, activityUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get activity: %w", err)
	}

	// Only sleep activities can be ended
	if activity.ActivityType != domain.ActivityTypeSleep {
		return nil, fmt.Errorf("only sleep activities can be ended")
	}

	// Get sleep details and update end time
	sleepDetails, err := r.store.GetSleepDetails(ctx, activityUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get sleep details: %w", err)
	}

	now := time.Now()
	if endTime == nil {
		endTime = &now
	}

	sleepDetails.EndTime = endTime
	duration := int(endTime.Sub(sleepDetails.StartTime).Minutes())
	sleepDetails.DurationMinutes = &duration
	sleepDetails.UpdatedAt = now

	if err := r.store.UpdateSleepDetails(ctx, sleepDetails); err != nil {
		return nil, fmt.Errorf("failed to update sleep details: %w", err)
	}

	fmt.Printf("‚úÖ Ended sleep activity %s at %s (duration: %d minutes)\n", activityID, endTime.Format(time.RFC3339), duration)

	// Return the sleep activity with details
	return &model.SleepActivity{
		ID:           activity.ID.String(),
		ActivityType: model.ActivityType(activity.ActivityType),
		CreatedAt:    activity.CreatedAt,
		SleepDetails: mapper.SleepDetailsToGraphQL(sleepDetails),
	}, nil
}

// CompleteCareSession is the resolver for the completeCareSession field.
func (r *mutationResolver) CompleteCareSession(ctx context.Context, notes *string) (*model.CareSession, error) {
	// Require authentication
	_, familyID, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get the current in-progress session
	session, err := r.store.GetInProgressSessionForFamily(ctx, familyID)
	if err != nil {
		return nil, fmt.Errorf("failed to get in-progress session: %w", err)
	}

	if session == nil {
		return nil, fmt.Errorf("no active session to complete")
	}

	// Update session to completed
	now := time.Now()
	session.Status = domain.StatusCompleted
	session.CompletedAt = &now
	session.Notes = notes
	session.UpdatedAt = now

	if err := r.store.UpdateCareSession(ctx, session); err != nil {
		return nil, fmt.Errorf("failed to complete care session: %w", err)
	}

	fmt.Printf("‚úÖ Completed care session %s\n", session.ID)

	return mapper.CareSessionToGraphQL(session), nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, activityID string) (bool, error) {
	// Require authentication
	_, _, err := middleware.RequireAuth(ctx)
	if err != nil {
		return false, fmt.Errorf("authentication required: %w", err)
	}

	activityUUID, err := uuid.Parse(activityID)
	if err != nil {
		return false, fmt.Errorf("invalid activity ID: %w", err)
	}

	// Delete the activity (cascades to details via DB foreign key)
	if err := r.store.DeleteActivity(ctx, activityUUID); err != nil {
		return false, fmt.Errorf("failed to delete activity: %w", err)
	}

	fmt.Printf("üóëÔ∏è  Deleted activity %s\n", activityID)

	return true, nil
}

// CheckFamilyNameAvailable is the resolver for the checkFamilyNameAvailable field.
func (r *queryResolver) CheckFamilyNameAvailable(ctx context.Context, name string) (bool, error) {
	exists, err := r.store.FamilyNameExists(ctx, name)
	if err != nil {
		return false, err
	}
	return !exists, nil // Return true if available (not exists)
}

// GetMyFamily is the resolver for the getMyFamily field.
func (r *queryResolver) GetMyFamily(ctx context.Context) (*model.Family, error) {
	panic(fmt.Errorf("not implemented: GetMyFamily - getMyFamily"))
}

// GetMyCaregiver is the resolver for the getMyCaregiver field.
func (r *queryResolver) GetMyCaregiver(ctx context.Context) (*model.Caregiver, error) {
	panic(fmt.Errorf("not implemented: GetMyCaregiver - getMyCaregiver"))
}

// loadCareSessionWithActivities loads all activities and details for a care session
func (r *queryResolver) loadCareSessionWithActivities(ctx context.Context, session *domain.CareSession) (*model.CareSession, error) {
	// Get all activities for the session
	activities, err := r.store.GetActivitiesForSession(ctx, session.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get activities: %w", err)
	}

	fmt.Printf("üìã Loading %d activities for session %s\n", len(activities), session.ID)

	// Load details for each activity and convert to GraphQL types
	graphQLActivities := make([]model.Activity, 0, len(activities))

	// Variables for summary calculation
	var totalFeeds, totalMl, totalDiaperChanges, totalSleepMinutes int32
	var lastFeedTime, lastSleepTime *time.Time
	var currentlyAsleep bool

	for _, activity := range activities {
		fmt.Printf("   üîç Processing activity %s (type: %s)\n", activity.ID, activity.ActivityType)
		switch activity.ActivityType {
		case domain.ActivityTypeFeed:
			fmt.Printf("   üì• Loading feed details for activity %s\n", activity.ID)
			feedDetails, err := r.store.GetFeedDetails(ctx, activity.ID)
			if err != nil {
				return nil, fmt.Errorf("failed to get feed details: %w", err)
			}
			fmt.Printf("   ‚úÖ Feed details loaded successfully\n")

			graphQLActivities = append(graphQLActivities, &model.FeedActivity{
				ID:           activity.ID.String(),
				ActivityType: model.ActivityType(strings.ToUpper(string(activity.ActivityType))),
				CreatedAt:    activity.CreatedAt,
				FeedDetails:  mapper.FeedDetailsToGraphQL(feedDetails),
			})

			// Update summary
			totalFeeds++
			if feedDetails.AmountMl != nil {
				totalMl += int32(*feedDetails.AmountMl)
			}
			feedTime := feedDetails.StartTime
			if lastFeedTime == nil || feedTime.After(*lastFeedTime) {
				lastFeedTime = &feedTime
			}

		case domain.ActivityTypeDiaper:
			diaperDetails, err := r.store.GetDiaperDetails(ctx, activity.ID)
			if err != nil {
				return nil, fmt.Errorf("failed to get diaper details: %w", err)
			}

			graphQLActivities = append(graphQLActivities, &model.DiaperActivity{
				ID:            activity.ID.String(),
				ActivityType:  model.ActivityType(strings.ToUpper(string(activity.ActivityType))),
				CreatedAt:     activity.CreatedAt,
				DiaperDetails: mapper.DiaperDetailsToGraphQL(diaperDetails),
			})

			// Update summary
			totalDiaperChanges++

		case domain.ActivityTypeSleep:
			sleepDetails, err := r.store.GetSleepDetails(ctx, activity.ID)
			if err != nil {
				return nil, fmt.Errorf("failed to get sleep details: %w", err)
			}

			graphQLActivities = append(graphQLActivities, &model.SleepActivity{
				ID:           activity.ID.String(),
				ActivityType: model.ActivityType(strings.ToUpper(string(activity.ActivityType))),
				CreatedAt:    activity.CreatedAt,
				SleepDetails: mapper.SleepDetailsToGraphQL(sleepDetails),
			})

			// Update summary
			sleepTime := sleepDetails.StartTime
			if lastSleepTime == nil || sleepTime.After(*lastSleepTime) {
				lastSleepTime = &sleepTime
			}
			if sleepDetails.DurationMinutes != nil {
				totalSleepMinutes += int32(*sleepDetails.DurationMinutes)
			}
			if sleepDetails.EndTime == nil {
				currentlyAsleep = true
			}
		}
	}

	// Get caregiver
	caregiver, err := r.store.GetCaregiverByID(ctx, session.CaregiverID)
	if err != nil {
		return nil, fmt.Errorf("failed to get caregiver: %w", err)
	}

	// Build GraphQL response
	return &model.CareSession{
		ID:          session.ID.String(),
		Caregiver:   mapper.CaregiverToGraphQL(caregiver),
		Status:      model.CareSessionStatus(strings.ToUpper(string(session.Status))),
		StartedAt:   session.StartedAt,
		CompletedAt: session.CompletedAt,
		Activities:  graphQLActivities,
		Notes:       session.Notes,
		Summary: &model.CareSessionSummary{
			TotalFeeds:         totalFeeds,
			TotalMl:            totalMl,
			TotalDiaperChanges: totalDiaperChanges,
			TotalSleepMinutes:  totalSleepMinutes,
			LastFeedTime:       lastFeedTime,
			LastSleepTime:      lastSleepTime,
			CurrentlyAsleep:    currentlyAsleep,
		},
	}, nil
}

// GetRecentCareSessions is the resolver for the getRecentCareSessions field.
func (r *queryResolver) GetRecentCareSessions(ctx context.Context, limit *int32) ([]*model.CareSession, error) {
	return GetMockRecentSessions(), nil
}

// GetCurrentSession is the resolver for the getCurrentSession field.
func (r *queryResolver) GetCurrentSession(ctx context.Context) (*model.CareSession, error) {
	// Get authenticated user
	_, familyID, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get in-progress session for family
	session, err := r.store.GetInProgressSessionForFamily(ctx, familyID)
	if err != nil {
		return nil, fmt.Errorf("failed to get in-progress session: %w", err)
	}

	// If no session exists, return nil
	if session == nil {
		return nil, nil
	}

	// Load activities and build GraphQL response
	return r.loadCareSessionWithActivities(ctx, session)
}

// GetCareSession is the resolver for the getCareSession field.
func (r *queryResolver) GetCareSession(ctx context.Context, id string) (*model.CareSession, error) {
	sessions := GetMockRecentSessions()
	currentSession := GetMockCurrentSession()

	// Check current session
	if currentSession.ID == id {
		return currentSession, nil
	}

	// Check recent sessions
	for _, session := range sessions {
		if session.ID == id {
			return session, nil
		}
	}

	return nil, fmt.Errorf("session not found: %s", id)
}

// PredictNextFeed is the resolver for the predictNextFeed field.
func (r *queryResolver) PredictNextFeed(ctx context.Context) (*model.NextFeedPrediction, error) {
	return GetMockPrediction(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
